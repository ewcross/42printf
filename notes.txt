to to:

	if val > 1.0

	0.9999 = 1.0
	1.0 - 0.9999 = 0.0001 - any number bigger than this means val is
							less than 0.9999 - so less than 1.0

	if val == 1.0

	0.9999 = 1.0
	1.0 - 1.0 = 0
	if |1.0 - 0.9999| < 0.0001


	- change exp getting function so it takes the ftoa output string
	  and looks at digits before point or null byte, then moves the point
	  or null byte to 

	- add rounding:
					- just re-write rounding functions so it rounds the
					  whole joined string, ignoring decimals and commas
	- rounding function needs to know previous digit:
					- when rounding just the mantissa can just go
					  (long long)(f * 10) to get next digit
					- but when rounding just the main part (i.e with
					  precision of zero (or negative?) or when a float
					  with no point is being converted), need to
					  give the previous digit to the function
					- also, when rounding just main part
					- end conditions:
										- finding a digit th:wq
										at is not a 9
										- finding a -, + or space
										- when i = 0 (or -1)
	- check rounding with commas

	- edit make_exp_str to handle formatting for exponent part of
	  output with %e
	- test %n with h and l
	- test + and space properly
	- test ' flag properly
	- find out about max unsigned long long - throws compiler error, and gives
	  strange output, but should work

	- add %g functions
	- add # functionality for g

	- %g:
			- let P equal the precision if nonzero, 6 if the precision is
			  omitted, or 1 if the precision is zero. Then, if a conversion
			  with style E would have an exponent of X:
 					
					if P > X ≥ −4, the conversion is with style f (or F)
 					and precision P − (X + 1).
     				
     				otherwise, the conversion is with style e (or E) and
     				precision P − 1.

precision:
	- d, i, o, u, x, X:
						- prec gives minimum number of printed digits
						- no truncation if prec < digits
						- if prec > digits, pad to left with zeros
	- s:
						- prec gives max number of chars printed
						- print chars until either prec or NULL byte
						  reached
	- f:
						- prec gives number of digits after decimal point
						- default should be 6
						- if prec is 0, no point printed, same for if just a '.'
						  with no specified width
						- if no digits after decimal point in variable,
						  prints default 6 zeros

size prefixes:

	- default size (for d, i o, u, x, X) - 4 bytes
	- hh makes it into 1 byte (char) data type
	- h - 2 bytes
	- l - 8 bytes
	- ll - 8 bytes

	- if size is smaller than int - cast down and then cast back to long long
	- if size is bigger than int - can just get bigger size

files:

	- ft_printf:
			-ft_printf

	- conv1:
			- c
			- s
			- p
			- di
			- u

	- conv2:
			- x
			- X

	- flag_processing:
			- set_flag_value
			- manage_flags
			- get_width
			- get_size_prefix
			- set_format

	- list_building:
			- flag_atoi
			- init_elem
			- add_elem
			- specifier_pos
			- make_list

	- output:
			- check_stars
			- write_padded
			- write_spec
			- write_plaintext
			- write_output

	- utils4:
			- negs
			- init_f_ptr_arr

	- utils1:
			- hex_convert
			- hex_get_mem_size
			- add_prefix
			- num_precision
			- str_precision

	- utils2:
			- get_mem_size
			- ft_itoa
			- u_get_mem_size
			- ft_u_itoa
			- push_back

	- utils3:
			- free_list
			- malloc_empty_string
			- pad
			- is_in
			- get_pos


process:

	- check for *s (-1 in flag_vals) and if present get next arg
	  and store in flag variable
	- do r, 0 or - first and then .
	- if 'type' is not in TYPE_SET, just store next plain text
	  char as the variable
	- otherwise use elem->type to get next arg with va_arg()
	- do the conversion (using . if necessary) and store this as the
	  variable in a malloced string
	- then count length of string and add preceeding or trailing chars
	  as needed

conversion functions:

	- each needs to take arg_list (to call arg of correct type) and precision
	- need to initialise an array of function pointers

type functions:

	- c:
			- write single byte
	- d/i:
			- write single signed int
			- use itoa with int data type
	- s:
			- write chars until NULL byte
			- also stops when precision value reached
	- p:
			- displays as address in hexadecimal
			- lowercase address with 0x prefix
	- u:
			- write single unsigned int
			- use itoa with unsigned int data type
	- x/X:
			- write unsigned hexadecimal integer
			- use itoa with unsigned, followed by hex convert
			- x uses "abcdef"
			- X uses "ABCDEF"

formatting

c	Character	When used with printf functions, specifies a single-byte character; when used with wprintf functions, specifies a wide character.
C	Character	When used with printf functions, specifies a wide character; when used with wprintf functions, specifies a single-byte character.
d	Integer	Signed decimal integer.
i	Integer	Signed decimal integer.
o	Integer	Unsigned octal integer.
u	Integer	Unsigned decimal integer.
x	Integer	Unsigned hexadecimal integer; uses "abcdef."
X	Integer	Unsigned hexadecimal integer; uses "ABCDEF."
e	Floating-point	Signed value that has the form [-]d.dddde±dd[d], where d is one decimal digit, dddd is one or more decimal digits depending on the specified precision, or six by default, and dd[d] is two or three decimal digits depending on the output format and size of the exponent.
E	Floating-point	Identical to the e format except that E rather than e introduces the exponent.
f	Floating-point	Signed value that has the form [-]dddd.dddd, where dddd is one or more decimal digits. The number of digits before the decimal point depends on the magnitude of the number, and the number of digits after the decimal point depends on the requested precision, or six by default.
F	Floating-point	Identical to the f format except that infinity and nan output is capitalized.
g	Floating-point	Signed values are displayed in f or e format, whichever is more compact for the given value and precision. The e format is used only when the exponent of the value is less than -4 or greater than or equal to the precision argument. Trailing zeros are truncated, and the decimal point appears only if one or more digits follow it.
G	Floating-point	Identical to the g format, except that E, rather than e, introduces the exponent (where appropriate).
a	Floating-point	Signed hexadecimal double-precision floating-point value that has the form [-]0xh.hhhhp±dd, where h.hhhh are the hex digits (using lower case letters) of the mantissa, and dd are one or more digits for the exponent. The precision specifies the number of digits after the point.
A	Floating-point	Signed hexadecimal double-precision floating-point value that has the form [-]0Xh.hhhhP±dd, where h.hhhh are the hex digits (using capital letters) of the mantissa, and dd are one or more digits for the exponent. The precision specifies the number of digits after the point.
n	Pointer to integer	Number of characters that are successfully written so far to the stream or buffer. This value is stored in the integer whose address is given as the argument. The size of the integer pointed at can be controlled by an argument size specification prefix. The n specifier is disabled by default; for information see the important security note.
p	Pointer type	Displays the argument as an address in hexadecimal digits.
s	String	When used with printf functions, specifies a single-byte or multi-byte character string; when used with wprintf functions, specifies a wide-character string. Characters are displayed up to the first null character or until the precision value is reached.
